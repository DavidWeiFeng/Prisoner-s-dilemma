# 置信区间实现说明 (Confidence Interval Implementation)

## 概述

本文档说明如何在囚徒困境模拟器中实现和报告95%置信区间（Confidence Intervals, CI）。

## 为什么需要置信区间？

在报告锦标赛结果时，仅仅提供平均分数是不够的。置信区间提供了以下重要信息：

1. **可靠性**: 显示结果的统计显著性
2. **稳健性**: 表明估计的精确度
3. **可比性**: 帮助判断两个策略的得分差异是否真实存在
4. **科学性**: 符合学术报告的标准

## 置信区间公式

### 95% 置信区间公式

```
95% CI = mean ± 1.96 × (stdev / √n)
```

其中：
- **mean**: 所有重复实验的平均分数
- **stdev**: 分数的标准差（样本标准差）
- **n**: 重复次数（repeats）
- **1.96**: 正态分布的Z值，对应95%置信水平

### 公式解释

1. **标准误差 (Standard Error, SE)**:
   ```
   SE = stdev / √n
   ```
   标准误差衡量样本均值的变异性。随着重复次数增加，SE减小，估计更精确。

2. **误差边界 (Margin of Error)**:
   ```
   Margin = 1.96 × SE
   ```
   1.96是标准正态分布的97.5百分位数，对应双侧95%置信区间。

3. **置信区间**:
   ```
   下限 = mean - 1.96 × SE
   上限 = mean + 1.96 × SE
   ```

## 实现细节

### 1. ScoreStats 结构体

在 `Simulator.h` 中定义：

```cpp
struct ScoreStats {
    double mean;        // 平均分
    double stdev;       // 标准差
    double ci_lower;    // 置信区间下限
    double ci_upper;    // 置信区间上限
    int n_samples;      // 样本数量
};
```

### 2. 统计计算函数

#### 计算均值和标准差
```cpp
std::pair<double, double> calculateStats(const std::vector<double>& scores) const {
    // 计算均值
    double sum = 0.0;
    for (double s : scores) sum += s;
    double mean = sum / scores.size();
    
    // 计算样本标准差（使用n-1作为分母，无偏估计）
    double variance = 0.0;
    for (double s : scores) {
        variance += (s - mean) * (s - mean);
    }
    variance /= (scores.size() - 1);
    double stdev = std::sqrt(variance);
    
    return {mean, stdev};
}
```

**注意**: 使用 `n-1` 而不是 `n` 作为分母，这是无偏的样本方差估计（Bessel's correction）。

#### 计算置信区间
```cpp
ScoreStats calculateConfidenceInterval(const std::vector<double>& scores) const {
    auto [mean, stdev] = calculateStats(scores);
    
    // 计算标准误差
    double se = stdev / std::sqrt(scores.size());
    
    // 计算误差边界（95% CI 使用 z = 1.96）
    double margin = 1.96 * se;
    
    // 返回完整的统计信息
    return ScoreStats(mean, stdev, mean - margin, mean + margin, scores.size());
}
```

### 3. 数据收集

在 `runTournament()` 中，我们跟踪每次重复的个别得分：

```cpp
std::map<std::string, std::vector<double>> allScores;

// 对于每次重复
for (int r = 0; r < repeats; ++r) {
    ScorePair scores = runGame(p1, p2, rounds);
    allScores[p1->getName()].push_back(scores.first);
    allScores[p2->getName()].push_back(scores.second);
}

// 计算统计信息
for (const auto& [name, scores] : allScores) {
    stats[name] = calculateConfidenceInterval(scores);
}
```

### 4. 结果显示

#### 排名表格
```
格式: 策略名称: 平均分 [95% CI 下限, 上限] (标准差)
基于 50 次重复实验

1. TFT                : 2.85  [2.78, 2.92]  (σ=0.45)
2. PAVLOV             : 2.76  [2.69, 2.83]  (σ=0.48)
3. CTFT               : 2.71  [2.64, 2.78]  (σ=0.50)
```

#### 噪声扫描表格
```
ε (Noise)  Strategy1              Strategy2
0.00       2.85 [2.78,2.92]       2.76 [2.69,2.83]
0.05       2.65 [2.58,2.72]       2.58 [2.51,2.65]
0.10       2.42 [2.35,2.49]       2.41 [2.34,2.48]
```

## 解读置信区间

### 示例 1: 重叠的置信区间

```
策略A: 2.80 [2.70, 2.90]
策略B: 2.75 [2.65, 2.85]
```

**解释**: 置信区间重叠，说明两个策略的真实均值可能相同，差异可能不显著。

### 示例 2: 不重叠的置信区间

```
策略A: 2.80 [2.75, 2.85]
策略B: 2.50 [2.45, 2.55]
```

**解释**: 置信区间不重叠，说明策略A确实优于策略B，差异具有统计显著性。

### 示例 3: 窄置信区间

```
策略A: 2.80 [2.78, 2.82]  (σ=0.15, n=100)
```

**解释**: 
- 窄区间说明估计精确
- 大量重复或低标准差导致
- 结果可靠性高

### 示例 4: 宽置信区间

```
策略B: 2.80 [2.50, 3.10]  (σ=2.10, n=10)
```

**解释**: 
- 宽区间说明不确定性大
- 少量重复或高标准差导致
- 需要更多重复来提高精度

## 影响置信区间宽度的因素

### 1. 重复次数 (n)

```
n = 10:   CI宽度 ∝ 1/√10  ≈ 0.316
n = 50:   CI宽度 ∝ 1/√50  ≈ 0.141
n = 100:  CI宽度 ∝ 1/√100 = 0.100
```

**建议**: 使用至少30-50次重复以获得合理的精度。

### 2. 标准差 (σ)

- **低标准差**: 策略表现稳定，CI较窄
  - 例如: ALLD vs ALLD 总是得到相同分数
  
- **高标准差**: 策略表现波动大，CI较宽
  - 例如: 在高噪声环境下的TFT

### 3. 置信水平

- **90% CI**: z = 1.645 (更窄)
- **95% CI**: z = 1.96 (标准)
- **99% CI**: z = 2.576 (更宽)

我们使用95%作为学术界的标准。

## 实际应用示例

### 场景: 比较PROBER vs ALLC

```
运行参数: 150 rounds, 50 repeats, ε=0.0

结果:
PROBER: 746.20 [743.15, 749.25]  (σ=21.80)
ALLC:     5.80 [  4.92,   6.68]  (σ=6.28)
```

**分析**:
1. PROBER平均每场得746分，ALLC得6分
2. 置信区间不重叠 → 差异高度显著
3. PROBER的标准差较大，因为探测期有变化
4. ALLC标准差较小，因为被完全剥削

### 场景: 比较TFT vs PAVLOV

```
运行参数: 150 rounds, 50 repeats, ε=0.05

结果:
TFT:    425.30 [422.10, 428.50]  (σ=22.80)
PAVLOV: 428.60 [425.20, 432.00]  (σ=24.30)
```

**分析**:
1. PAVLOV平均分略高于TFT
2. 置信区间略有重叠 → 差异可能不显著
3. 两者标准差相似，都受噪声影响
4. 需要更多重复或降低噪声来确定优劣

## 报告最佳实践

### 1. 完整报告格式

```
策略性能（150轮/场，50次重复，ε=0.0）:

排名  策略     平均分      95% CI           标准差
----  ------  ---------  ----------------  -------
1.    TFT     285.40     [282.15, 288.65]  23.20
2.    PAVLOV  276.80     [273.50, 280.10]  23.60
3.    CTFT    271.20     [268.00, 274.40]  22.90
```

### 2. 对比分析

```
关键对战分析（平均分 ± 95% CI）:

PROBER vs ALLC:
  - PROBER: 4.97 ± 0.04 /轮
  - ALLC:   0.04 ± 0.01 /轮
  → PROBER显著优于ALLC (p < 0.001)

PROBER vs TFT:
  - PROBER: 3.00 ± 0.08 /轮
  - TFT:    2.97 ± 0.08 /轮
  → 两者无显著差异 (p > 0.05)
```

### 3. 噪声影响报告

```
噪声对TFT的影响（平均分 ± 95% CI）:

ε     平均分      95% CI           下降%
----  ---------  ----------------  -----
0.00  285.40     [282.15, 288.65]  0%
0.05  265.20     [262.00, 268.40]  7%
0.10  242.80     [239.50, 246.10]  15%
0.15  218.60     [215.20, 222.00]  23%
0.20  195.30     [192.00, 198.60]  32%
```

## 技术注意事项

### 1. 正态性假设

95% CI公式基于正态分布假设。这在以下情况下合理：
- 重复次数较多（n ≥ 30）
- 中心极限定理适用
- 我们使用50次重复，满足此条件

### 2. 独立性

每次重复应该是独立的：
- ✓ 使用不同的随机种子
- ✓ 每场比赛重置策略状态
- ✓ 策略不保留上一场的记忆

### 3. 精度考虑

- 显示2位小数足够（例如: 2.85）
- CI边界也显示2位小数
- 标准差可以显示2位小数

## 总结

### 关键要点

1. **始终报告置信区间**: 不要只报告平均分
2. **解释CI含义**: 说明95%置信水平的意义
3. **比较CI重叠**: 判断差异是否显著
4. **足够的重复**: 至少30-50次重复
5. **完整的信息**: 包括mean, CI, stdev, n

### 公式速查

```
标准误差:  SE = σ / √n
误差边界:  Margin = 1.96 × SE
置信区间:  CI = mean ± Margin
          = mean ± 1.96 × (σ / √n)
```

### 代码位置

- **定义**: `Simulator.h` - `ScoreStats` 结构体
- **计算**: `Simulator.h` - `calculateConfidenceInterval()` 方法
- **显示**: `SimulatorRunner.cpp` - `printResults()` 方法

---

**实现日期**: 2024
**统计方法**: 95% 置信区间（正态分布近似）
**验证状态**: ✓ 已实现并测试
